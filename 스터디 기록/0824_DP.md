# 0824 | DP | 문제풀이모음



# 📚 커리큘럼

- 주제 : DP
- 공통문제
  - [백준/실버3]  피보나치 함수 https://www.acmicpc.net/problem/1003
  - [백준/실버3] 01타일 https://www.acmicpc.net/problem/1904



# 🔠 공통문제 1

## ⌛ 문제

다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.

```
int fibonacci(int n) {
    if (n == 0) {
        printf("0");
        return 0;
    } else if (n == 1) {
        printf("1");
        return 1;
    } else {
        return fibonacci(n‐1) + fibonacci(n‐2);
    }
}
```

`fibonacci(3)`을 호출하면 다음과 같은 일이 일어난다.

- `fibonacci(3)`은 `fibonacci(2)`와 `fibonacci(1)` (첫 번째 호출)을 호출한다.
- `fibonacci(2)`는 `fibonacci(1)` (두 번째 호출)과 `fibonacci(0)`을 호출한다.
- 두 번째 호출한 `fibonacci(1)`은 1을 출력하고 1을 리턴한다.
- `fibonacci(0)`은 0을 출력하고, 0을 리턴한다.
- `fibonacci(2)`는 `fibonacci(1)`과 `fibonacci(0)`의 결과를 얻고, 1을 리턴한다.
- 첫 번째 호출한 `fibonacci(1)`은 1을 출력하고, 1을 리턴한다.
- `fibonacci(3)`은 `fibonacci(2)`와 `fibonacci(1)`의 결과를 얻고, 2를 리턴한다.

1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, `fibonacci(N)`을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.

### 출력

각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.



# 🔑 풀이



## 🔸 재승 joney0715

```python
d = [0] * 41
d[0] = [0, 1, 0]
d[1] = [1, 0, 1]
def fibo(N):
    if N == 1:
        return d[1]
    
    if d[N]:
        return d[N]
   
    d[N] = [fibo(N-1)[0] + fibo(N-2)[0], fibo(N-1)[1] + fibo(N-2)[1], fibo(N-1)[2] + fibo(N-2)[2]]
    return d[N]

T = int(input())

for _ in range(T):
    N = int(input())

    if N == 0:
        print(1, 0)
    else:
        fibo(N)

        print(d[N][1], d[N][2])
```

### 로직

- 전체 로직
  - 0이 호출된 횟수와 1이 호출된 회수를 피보나치 수열에 같이 넣어서 연산



## 🔸 은지 angielxx

```python
T = int(input())

for _ in range(T):
    N = int(input())

    zero_list = [1, 0]
    one_list = [0, 1]

    for i in range(2, N+1):
        zero = zero_list[i-1] + zero_list[i-2]
        one = one_list[i-1] + one_list[i-2]

        zero_list.append(zero)
        one_list.append(one)

    print(zero_list[N], one_list[N])
```

### 로직

- 0과 1도 피보나치 수열로 이어지기 때문에, 각각 피보나치 수열로 구현하여 정답을 구했다.



## 🔸 찬빈 Rlack97

```python
T = int(input())

list0 = [0]*41
list0[0] = 1
for i in range(2,41):
    list0[i] = list0[i-1] + list0[i-2]

list1 = [0]*41
list1[1] = 1
for i in range(2,41):
    list1[i] = list1[i-1] + list1[i-2]

# 피보나치 수열 리스트 작성

for _ in range(T):
    N = int(input())
    print (list0[N], list1[N])
```

### 로직

- 계산해보면 0 출력 횟수와 1출력 횟수 역시 피보나치 수열을 형성하고 있음
- N이 40까지이므로 미리 전체 리스트를 구한 뒤 값 추출

### 배운 점

- 피보나치인지 빠르게 눈치채는게 중요하지만, 작은 값만 보고 결정했다간 뒤통수에 주의



## 🔸 승준 ksj970714

```python
a = [1, 0]
b = [0, 1]

for i in range(2, 41):
    x = a[i - 1] + a[i - 2]
    y = b[i - 1] + b[i - 2]
    a.append(x)
    b.append(y)

T = int(input())

for i in range(T):
    N = int(input())
    print(a[N], b[N])
```

### 로직

- 전체 로직
  - 0과 1의 갯수를 피보나치 수로 생각해주면 쉽게 풀리는 문제였다.
  - 처음엔 조금 어렵게 생각했으나 1번째 항에선 0이 1개, 2번째 항에선 1이 1개, 2번째 항에선 0과 1이 1개, 2번째 항에선 0이 2개 1이 1개.. 이런식으로 생각해주었다.
  - a: 0의 갯수를 표시하는 벡터, b: 1의 갯수를 표시하는 벡터.

### 배운 점

1. DP라는 개념은 처음에 잘 와닿지 않는다. 이를 설명하기 위해 피보나치 수열을 많이 사용하는데 굉장히 좋은 접근법인 것 같다.



## 🔸 유진 yjp8842

```python
# 낮은 값이 높은 순위를 가짐 (0순위부터)
# 중복되는 값은 같은 순위를 가짐

# len 함수 구현
def len(a_list) :
	cnt = 0
	for _ in a_list:
		cnt += 1
	return cnt

N = int(input())
nums = list(map(int, input().split()))
sort_nums = sorted(set(nums)) # 중복을 제외한 값들을 오름차순으로 정렬
num_dict = {}

for i in range(len(sort_nums)):
    num_dict[sort_nums[i]] = i # {-10: 0, -9: 1, 2: 2, 4: 3}

for num in nums:
    print(num_dict.get(num), end=" ") # 값에 해당하는 value값 불러오기
```

### 로직

- 우선 입력받은 정수들을 set(), sorted()를 활용하여 중복을 제거하고 오름차순으로 정렬해준다. 그 다음 딕셔너리를 활용하여 각각의 인덱스를 value에 할당시켜준다. 마지막으로 입력받은 순서대로 각각의 value 값을 출력해준다.

### 배운 점

- 처음에는 너무 쉽게 생각해서 이중 for문으로 문제를 해결하는 로직을 짰지만 자료구조, 정렬 문제들은 항상 시간초과의 문제가 있어서 어떻게 해결해야 할까라는 로직을 구상하는데 시간이 좀 걸렸던 것 같다.



# 🔠 공통문제 2

## ⌛ 문제

지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.

어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.

그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.

우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.

### 입력

첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)

### 출력

첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.



# 🔑 풀이



## 🔸 재승 joney0715

```python
N = int(input())

if N == 1:
    print(1)
else:
    d = [0] * (N+1)
    d[1] = 1
    d[2] = 2

    for i in range(3, N+1):
        d[i] = (d[i-1] + d[i-2]) % 15746

    print(d[N])
```

### 로직

- 전체 로직
  - 메모이제이션을 사용하여 전의 계산 값을 사용
  - 1타일을 뺀 N-1길이의 타일의 경우와 00타일을 뺀 N-2길이의 타일의 경우를 더해서 길이가 N인 타일을 만들 수 있음



## 🔸 은지 angielxx

```python
N = int(input())

dp = [0] * 1000001
dp[1] = 1
dp[2] = 2

for i in range(3, N+1):
    dp[i] = (dp[i-1] + dp[i-2])%15746

print(dp[N])
```

### 로직

- 리스트를 탐색하는 횟수를 줄이기 위해 DP를 생성할 때 바로 출력값인 15746으로 나눈 값을 구하도록 했다.



## 🔸 찬빈 Rlack97

```python
N = int(input())

# 재귀
# def count(n):
#     if n == 1:
#         return 1
#     if n == 2:
#         return 2
#     else:
#         return count(n-1) + count(n-2)
# 재귀 깊이가 1000이 넘어가 RecursionError가 발생

# 리스트에 저장
# list = [1,2]
# for i in range(3,N+1):
#     value = list[i-3] + list[i-2]
#     list.append(value)
# C = list.pop()
# 메모리 초과 발생

# 변수에 저장 
# a = 1
# b = 2
# for i in range(3,N+1):
#     a, b = b, a+b
# 시간 초과 발생


list = [0,1,2]
for i in range(3,N+1):
    value = (list[i-2] + list[i-1]) % 15746 # 계속 나머지를 구하는 것으로 메모리 확보
    list.append(value) 

print(list[N])
# pop으로 뽑으려고 했으나, N이 2 이하면 값이 달라져버림.
```

### 로직

- 재귀로 할 시 호출수가 너무 늘어남.
- DP를 통해, 작은 값부터 계산해 나가면서 이 값을 리스트에 저장
- 그 후 원하는 지점의 값을 가져옴

### 배운 점

- 메모리 초과는 전체의 길이뿐만 아니라 각 요소의 사이즈가 커지는 경우도 고려.
- 더한 후 나머지를 구하는 문제는, 나누면서 더해도 큰 상관이 없다



## 🔸 승준 ksj970714

```python
a = [0] * 1000001
a[1] = 1
a[2] = 2

N = int(input())

for i in range(3,N+1):
    a[i]=(a[i-1]+a[i-2])%15746

print(a[N])
```

### 로직

- 전체 로직
  - 1000000개짜리 배열을 선언하고, 거기의 빈칸을 채워가는식으로 설계하였다.
  - 어떻게 채워나가는가?
    - 일단 1번칸은 1타일만 들어갈 수 있으니 1가지, 2번칸은 00과 11로 될 수 있으니 2다. 여기서 3번칸은 2번칸에 1번칸을 더하는 것이다. n-1번째 항에 1을 붙이는 것, 그리고 n-2번째 항에 00을 붙이는 것으로 n번째 항의 모든 원소를 만들 수 있기 때문에 이러한 점화식이 성립하게 된다.
    - 피보나치 수열과 일견 유사한 부분도 존재한다. 이 규칙을 찾는 것 자체는 쉬웠으나, 자꾸 시간초과가 나서 생각한 방법이 저 엄청 큰 배열을 선언하고 채워가는 것이었다.
    - 숫자 자체가 커서 메모리초과가 나는 것은, 각 항을 미리미리 15746으로 나눠주는 것으로 해결하였다.

### 배운 점

1. 공간 복잡도를 희생해 시간복잡도를 개선한다! 커다란 배열을 선언해 필요할때만 인덱싱해주면 일단 리스트를 구하고 나면 O(1)만에 구할 수 있으니..
2. 먼저 나눠놓는 식으로 공간복잡도를 개선하는 방법은 나중에 어려운 문제를 할 떄도 응용해보면 좋을 것 같다!



## 🔸 유진 yjp8842

```python
N = int(input())

# DP 활용
# N이 3 이상일 때부터는 경우의 수 == 그 전 + 그 전전 단계의 경우의 수
dp = [0, 1, 2]
for i in range(3, N + 1):
    dp.append((dp[i - 1] + dp[i - 2]) % 15746)
    
print(dp[N])
```

### 로직

- N이 3 이상일 때부터는 경우의 수가 그 전과 그 전전 단계의 경우의 수를 더한 값으로 이루어진다는 것을 참고해서 로직을 구현했다.

### 배운 점

- 위의 문제와 마찬가지로 어떤 리스트에 값을 append 해줄 때 바로 넣어주는 것보다 변수를 하나 만들어서 나중에 디버깅 할 때 더 보기 쉽도록 코드를 짜는 것이 좋다.