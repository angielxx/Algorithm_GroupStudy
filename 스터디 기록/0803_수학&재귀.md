# 0803 | 수학, 재귀 | 문제풀이 모음



# 📚 커리큘럼

- 주제 : 수학, 재귀

- 공통문제

  - [백준/골드5] 2447. 별 찍기 https://www.acmicpc.net/problem/2447

  - [백준/실버3] 4948. 베르트랑 공준 https://www.acmicpc.net/problem/4948

    

# 🔠 공통문제 1



## ⌛ 문제

재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.

크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.

```python
***
* *
***
```

N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.

### 입력

첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k 이며, 이때 1 ≤ k < 8이다.

### 출력

첫째 줄부터 N번째 줄까지 별을 출력한다.



# 🔑 풀이



## 🔸 재승 joney0715

```python
def star(x, y, N):
    # 3개인 경우 점 찍기
    if N == 3:
        M[x][y] = M[x][y+1] = M[x][y+2] = '*'
        M[x+1][y] = M[x+1][y+2] = '*'
        M[x+2][y] = M[x+2][y+1] = M[x+2][y+2] = '*'
    else:
        n = N // 3
        # 첫번째 줄
        star(x, y, n)
        star(x+n, y, n)
        star(x+(2*n), y, n)

        # 두번째 줄
        star(x, y+n, n)       
        star(x+(2*n), y+n, n)

        # 세번째 줄
        star(x, y+(2*n), n)
        star(x+n, y+(2*n), n)
        star(x+(2*n), y+(2*n), n)

N = int(input())
# 점을 찍기위한 맵 생성
M = [[' '] * N for _ in range(N)]

# 함수 불러오기
star(0, 0, N)

# 점 찍기
for i in M:
    print(''.join(i))
```

### 로직

- 전체 로직
  - 별을 찍기위한 값이 비어있는 2차원 배열(N*N) 생성
  - 재귀 규칙
    - 함수 입력값은 별을 찍기 시작하는 시작 좌표(x, y)와 N
    - 3*3인 경우를 재귀 종료 조건으로 설정
    - 3*3은 적절한 위치에 별을 찍어둠
    - N이 3을 초과하는 수인 경우는 N을 3으로 나누어서 9개의 영역에 대해 재귀

### 어려웠던 점

1. 재귀 로직을 생각해 내는 것이 어려웠다.
   - 재귀 종료 조건 설정을 위해 최소 단위 설정을 별 하나로 할지 3*3으로 할지 고민을 했다.
   - 일정한 패턴이 반복되기 때문에 패턴을 잘 녹인 재귀를 설정할 필요가 있었다



## 🔸 은지 angielxx

```python
N = int(input())

arr = list()
for i in range(N):
    arr.append(['*'] * N)

def count(N):
    k = 0
    while True:
        if N == 1:
            break
        else:
            N /= 3
            k += 1
    return k
k = count(N)

# 반복에 사용될 3의 거듭제곱 숫자들
numbers = [3**i for i in range(k)]
# 바꿀 행과 열의 정보를 저장
to_change = list()

for i in numbers:
    idx = numbers.index(i)
    index_list = list()
    
    for j in range(i):
        k = 0
        while i + (3 ** (idx + 1) * k) < N:
            index_list.append(i + (3 ** (idx + 1) * k) + j) 
            k += 1
    to_change.append(index_list)

for idx_list in to_change:
    for i in idx_list:
        for j in idx_list:
            arr[i][j] = ' '
                
for i in range(N):
    print(''.join(arr[i]), end='\\n')
```

### 로직

- 전체 로직
  - N*N 크기의 ‘*’로 가득채워진 2차원 배열에서 공백으로 바뀐 인덱스의 규칙성에 주목하여 반복문으로 구현하였다.
  - 인덱스 규칙
    - 빈칸 크기가 1일 때 : 1, 4, 7, 10, 13, 16, 19, 22, 25 -> 첫번째 인덱스 1, **연속 1개씩, 다음 번호는 3**1씩 증가**
    - 빈칸 크기가 3일 때 : 3,( 4, 5,) 12,( 13, 14,) 21,( 22, 23) -> 첫번째 인덱스 3, **연속 3개씩, 다음 번호는 3**2씩 증가**
    - 빈칸 크기가 9일 때 : 9,( 10, 11, 12, 13, 14, 15, 16, 17) -> 첫번쨰 인덱스 9, **연속 9개씩, 다음 번호는 3**3씩 증가**

### 어려웠던 점

1. 이차원 리스트 만들 때, 얕은 복사에 주의하자!
   - 처음에 별(*)로 이루어진 가로, 세로가 N 크기인 2차원 리스트를 만들 때
   - arr = [ ['*'] * N] * N
   - 위와 같이 만들어서 리스트 안의 모든 리스트들이 하나의 객체 참조를 가지게 되었다.
   - 그래서 반복문을 사용해서 이차원 리스트를 만드는 것으로 코드를 수정했다.
   - for i in range(N): arr.append(['*'] * N)
2. 재귀를 공부하자….
   - 재귀로 푸는 방법을 개인적으로 꼭 연습해봐야할 것 같다.



## 🔸 찬빈 Rlack97

```python
## 각자 풀이한 코드를 적어주세요 ##
def star(N):
    if N == 1:
        return '*'
    else:
        print(star(N//3)*3)
        print(star(N//3) + ' '*(N//3) + star(N//3))
        print(star(N//3)*3)

N = int(input())

star(N)
```

### 로직

- 전체 로직
  - list 안의 list를 통해 맵핑하는 개념을 이해하지 못하고, N=3인 경우를 하드코딩 후 종료.

### 어려웠던 점

1. 이중 리스트를 통해 A[x][y] = (x,y)를 표현 할 수 있는 걸 잊지 말자
2. 재귀는 함숫값이 끝나는 지점을 생성 하는 게 중요
3. 매핑의 경우, 함수로는 리스트만 생성하고 출력은 별도 식을 사용하는 것이 더 나음



## 🔸 승준 ksj970714

```python
N=int(input())
N_list=[]
s=1
while s*3!=N:
    s = s*3
    N_list.append(s) #3 9 27 등 3의 제곱수를 뽑는것, 재귀를 못 짜서 이렇게 함

s=[[1,1,1],[1,0,1],[1,1,1]]
def makelist(s,N):
    slist=[]
    for i in range(N):
        slist.append(s[i]*3)
    for i in range(N):
        slist.append(s[i]+[0]*N+s[i])
    for i in range(N):
        slist.append((s[i]*3))
    return(slist)
# 별이 있는지점은 1 별이 없으면 0인 리스트 만듬
        
'''
***   ***   ***
* *   * *   * *
***   ***   ***
'''

def star(lists,N):
    for i in range(N):
        for j in range(N):
            if lists[i][j]==1:
                print('*',end='')
            else:
                print(' ',end='')
        print() #해당 위치에 1이 있으면 별출력 아니면 빈칸 출력

for i in N_list: #순서대로 3, 9, 27..을 집어넣기
    s=makelist(s,i) 
star(s,N)'''
```

### 로직

- 전체 로직

  - 3, 9, 27.. 로 단계가 증가될때마다, 전 단계의 모양이 붙는 규칙성에 주목하였다.
  - 예를 들면 n=27일 때 첫 9줄동안은 n=9일때의 모양 3개가 가로로 늘어서있고, 다음 9줄은 n=9일때의 모양 하나, 9*9 크기의 텅 빈 모양 하나,  또 오른쪽엔 n=9일때의 모양이 존재한다. 맨 아랫줄은 첫 9줄과 같다.

- 이에 착안해 전 단계의 첫 줄을 현재 단계의 모형에 세번 붙여넣고, 둘째 줄을 세번 붙여넣고.. 하는 식으로 반복한다.

- ------

------

------

예를 들어 n=9인경우 이런 식의 모형을 첫줄부터 한줄씩 완성하는 식으로 해준다.

***   ***   *** → *  *  *  *   *  * → ***   ***   ***

n=27인 경우 n=9일때의 첫줄을 3번 반복, 둘째줄을 3번 반복.. 이를 아홉째줄까지 해준다. 이후 다음에 오는 것은 가운데가 텅 비었기 때문에 n=9일 때의 첫줄을 한번 써주고 0을 9개 채워넣고, 이후 n=9일때의 첫줄을 한 번 더 써주는 식으로.

- 이후 star() 함수를 통해, 인덱스에 1이 들어가있는 경우 별을 찍어준다.

### 어려웠던 점

1. 재귀를 구현하고 싶었는데, 어떤식으로 재귀를 구현할지 몰라서 어려웠다.
   - 코드상으로 재귀를 구현하기 힘들어서, n=27일경우 3, 9, 27.. 을 순서대로 집어넣는식으로 유사재귀를 구현하였다.







# 🔠 공통문제 2



## ⌛ 문제

재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.

크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.

```python
***
* *
***
```

N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.

### 입력

첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k 이며, 이때 1 ≤ k < 8이다.

### 출력

첫째 줄부터 N번째 줄까지 별을 출력한다.



# 🔑 풀이



## 🔸재승 joney0715

```python
# 소수 카운팅 함수
def count_prime(N):
    count = 0
    # N과 2N 사이의 범위 
    for n in range(N+1, 2*N+1):
        if prime[n]:
            count += 1
    return count

# 제한 범위 내의 소수를 미리 계산해둠
n = 123456 * 2 + 1
prime = [True] * n
# 소수인지 판별할 숫자의 제곱근
# 제곱근이 대략 약수 중간이기 때문 
for i in range(2, int(n**0.5)+1):
    # 과거의 계산으로 i가 소수가 아니라면 처리하지 않음
    # i가 소수가 아니라면 i의 배수도 전부 소수가 아닌 상태
    if prime[i]:
        # 에라토스테네스 체로 소수 아닌 숫자 거르기
        # i의 배수를 전부 소수가 아닌 것으로 처리
        for j in range(2*i, n, i):
            prime[j] = False

# 테스트 데이터 입력
Num = []
while True:
    N = int(input())
    if N == 0:
        break
    Num.append(N)

# 연산
for N in Num:
    print(count_prime(N))
```

### 로직

- 전체 로직
  - 제한 범위 내의 모든 소수를 구해놓고 입력값을 받아서 구해놓은 소수에서 인덱스 검색만 실시
  - 소수 구하는 로직
    - 소수인지 아닌지 판별하기 위한 숫자의 제곱근까지 소수가 아닌 수를 걸러냄
      - 정수론에 따르면 제곱근이 약수에 중간에 근접함
    - 걸러내는 알고리즘은 에라토스테네스의 체를 사용

### 어려웠던 점

1. 여러 방법을 써봤지만 시간 초과가 발생했기 때문에 시간을 줄이기 위한 메커니즘이 필요했다.



## 🔸 은지 angielxx

```python
all = range(1,123456*2) # 100000까지만 생각하고, 요구한 범위대로 안하니까 오답..
prime_numbers = list()
for i in all: # 오답! = 반복문, range를 줄이니까 답이 금방나옴
    for j in range(2, int(i**(1/2)) + 1):
        if i % j == 0:
            break
    else:
        prime_numbers.append(i)

while True:
    n = int(input())
    if n == 0:
        break
    else:
        cnt = 0
        for i in prime_numbers:
            if n < i <= 2*n:
                cnt += 1
    print(cnt)
```

### 로직

- 전체 로직
  1. 주어진 범위 안의 소수를 미리 찾아놓는다.
  2. 소수를 찾을떄는, 입력되는 숫자의 제곱근까지만 약수를 찾아 소수를 판별한다.
  3. 입력된 숫자의 범위에서 ( n ~ 2n) 소수 목록에 있으면 카운트를 한다.

### 어려웠던 점

1. 시간초과의 늪
   - 시간초과가 계속해서 나왔다…시간 복잡도에 대한 지식도 없고 해서, 구글링을 통해 아이디어를 살짝 얻고 구현은 직접 했다.
   - 시간초과하는 문제를 없애려면 반복문을 줄여야하고, 미리 만들어놓을 수 있는건 미리 세팅해놓는 것이 좋다.



## 🔸 찬빈 Rlack97

```python
max = 123456

A = [1]*(max*2+1)

A[0] = 0
A[1] = 0

for i in range(2,len(A)//2):
    for j in range(i + i, len(A), i):
        A[j] = 0

T = []
while True:
    n = int(input())
    if n == 0:
        break
    else:
        T.append(sum(A[n+1:2*n+1]))

for k in range(len(T)):
    print(T[k])
```

### 로직

1. 가능한 범위의 최댓값의 인덱스까지 1로 이루어진 리스트를 생성
2. 0과 1은 소수가 아님
3. 약수 판별식
   1. 2부터 A값의 루트 2까지의 수들로
      1. 해당 수의 배수들을 전부 0으로 변환
4. 결과를 받을 빈 리스트
   1. 입력값을 받고, 결과를 나눠서 출력

### 중요한 부분

1. 각 입력값에 대해 계산하는 것이 아니라, 미리 리스트를 구해 놓고 해당하는 범위를 탐색
2. 약수의 수는 해당 수의 2루트 값까지만 구하면 된다.



## 🔸 승준 ksj970714

```python
'''
먼저 n<=123456이고, 최대로 조사해야 하는것이 2n까지이므로,
2*123456까지 소수인지 판별할 수 있다면 이 문제는 해결된다.
그러나 자연수 n이 소수인지 판별할때 흔히 쓰는 방법인,
n의 제곱근 미만의 수로 다 나눠보는 방법은 시간초과가 뜬다.
(4, 6등 소수가 아닌 수로도 나누게됨)
따라서 이를 해결하기 위해 500까지의 소수를 미리 리스트로 구해놓고 활용
123456*2는 500의 제곱(250000)보다 작으니까.
'''

prime_number = [2]
prime = []
for i in range(3,500):
    for j in range(len(prime_number)):
        if i % prime_number[j] == 0:
            break
    else: 
        prime_number.append(i)        
'''
앞서 언급한 2~500 사이의 소수를 구하는 과정
리스트에 2를 넣고 시작(리스트에 아무것도 안 넣으면 인덱스에러가 났던것 같음) 
i보다 작은 어떤 소수로도 나누어떨어지지 않으면
(즉, i가 소수로 판별되면) 리스트에 집어넣음. 
따라서 prime_number에는 500보다 작은 소수만 들어있게 됨
'''     
for i in range(500,123456*2):
    for j in range(len(prime_number)):
        if i % prime_number[j] == 0:
            break
    else: 
        prime.append(i)
prime.extend(prime_number) 
#500이상의 소수만 있는 prime에 500이하의 소수가 들어있는 prime_number 추가.
'''
prime_number로 500~123456*2 범위 안의 수를 나눠보며 소수를 판별함.
'''

while True:        
    N = int(input())
    if N == 0 :
        break
    count = 0
    for i in prime:
        if N < i <= 2*N :
            count += 1
        
    print(count)

'''
N을 입력받아, prime에 속하는 원소가 N과 2N사이의 범위에 있다면
카운트+1을 해줌으로서 구간 사이의 소수의 수를 구한다.
'''
```

### 로직

- 전체 로직
  - n의 최댓값이 123456이고, n 보다 크고 2n보다 작은 소수를 판별해야 한다. 따라서 123456 *2 이하의 소수만 판별하면 된다.
  - 250000 이하의 소수를 전부 구해놓고 리스트에 집어넣은 뒤, 해당 구간 사이에 리스트에 포함된 소수가 얼마나 되는지 세는 for문을 활용하였다.
  - n이 소수인지 판별하기 위해선 n의 제곱근까지만 나눠보면 되기 때문에, 최대 250000까지의 소수를 판별하기 위해선 500까지의 수 중 어떤 수가 소수인지만 알면 된다. 따라서 500까지의 소수를 구함(이를 prime_number이라는 리스트에 집어넣음) → 이 prime_number에 속하는 소수들로 250000까지의 수를 나눠보며 판별하였다.
  - 소수 판별 후 prime이라는 리스트에 소수들을 집어넣은 뒤 구간 안에 몇개가 있는지 확인하였다.

### 어려웠던 점

- 시간초과가 많이 발생하였다. 애초에 간단한 소수 구하는 이중 for문으로 구현하던 초보들에게 철퇴를 내리기 위해 만든 그런 문제였던 것 같다. 특히, 여러개의 n을 집어넣을때 소수 판별하는 for문이 중복으로 작동되는것이 시간초과의 주요한 문제였던 것 같다.
- 이 문제를 계기로 big-O에 대해 기초적인 부분을 알게 되었고, 어떤 알고리즘이 코딩 테스트에서 필요한 알고리즘인가? 에 대해 알게 되었다.



## 🔸 유진 yjp8842

```python
import math

def is_prime(num): # 소수 구하는 함수
    if num == 1:
        return False
    else:
        for n in range(2, int(math.sqrt(num)) + 1): # 제곱근까지로 검사 범위를 줄여줌
            if num % n == 0:
                return False
    return True

is_prime_list = [] # 빈 리스트 선언
nums = list(range(2, 246912)) # 범위를 제한하여 시간 초과 예방
for ns in nums:
    if is_prime(ns):
        is_prime_list.append(ns)
        
while True:
    cnt = 0
    N = int(input())
    if N == 0: # 마지막 입력값 0
        break
    
    for value in is_prime_list:
        if N < value <= N * 2: # 주어진 범위 안에 있는 소수 카운트
            cnt += 1
            
    print(cnt)
```

### 로직

- 우선 소수를 구하는 함수를 정의해주었다. 소수면 True를 반환하게 했고, 정의한 소수 함수를 통해 주어진 범위 내의 모든 소수를 담은 리스트를 만들었다. 그리고 N이 주어졌을 때 N과 N*2 사이에 있는 소수만 카운트하여 출력해주었다.

### 어려웠던 점

- 시간 초과를 어떻게 해결할 지에 대한 고민이 있었다.