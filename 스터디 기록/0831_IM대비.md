# 0824 | DP | 문제풀이모음



# 📚 커리큘럼

- 주제 : 정렬

- 공통문제

  - [백준/실버3] : 최고의 피자 - https://www.acmicpc.net/problem/5545
  - [백준/실버1] : 신입사원 - https://www.acmicpc.net/problem/1946

  

# 🔠 공통문제 1

## ⌛ 문제

상근이는 근처 피자 가게에서 매일 저녁으로 피자를 배달해 먹는다. 주머니 사정이 얇아진 상근이는 이번 달부터는 "최고의 피자"를 구매하려고 한다. 최고의 피자란, 피자 가게에서 주문할 수 있는 피자 중 1원당 열량이 가장 높은 피자를 말한다. 최고의 피자는 여러 종류가 있을 수도 있다.

이 피자 가게는 토핑 N개에서 여러 종류를 선택해서 주문할 수 있다. 같은 종류의 토핑을 2개 이상 선택할 수는 없다. 또, 토핑을 전혀 선택하지 않을 수도 있다.

선택한 토핑은 도우 위에 올라간다. 도우의 가격은 A원이고, 토핑의 가격은 모두 B원이다. 피자의 가격은 도우와 토핑의 가격의 합계가 된다. 즉, 토핑을 k종류 (0 ≤ k ≤ N) 선택했다면, 피자의 가격은 A + B*k원이 된다. 피자의 열량은 도우와 토핑의 열량의 합이다.

도우의 가격, 토핑의 가격, 그리고 도우와 각 토핑의 열량 값이 주어졌을 때, 최고의 피자의 1원 당 열량을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 토핑의 종류의 수 N(1 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 도우의 가격 A와 토핑의 가격 B가 주어진다. (1 ≤ A, B ≤ 1000) 셋째 줄에는 도우의 열량 C가 주어진다. (1 ≤ C ≤ 10000) 다음 줄부터 N개 줄에는 각 토핑의 열량 Di 가 한 줄에 하나씩 주어진다. (1 ≤ Di ≤ 10000)

### 출력

첫째 줄에 최고의 피자의 1원 당 열량을 출력한다. 소수점 이하는 버리고 정수 값으로 출력한다.



# 🔑 풀이



## 🔸 재승 joney0715

```python
N = int(input())

# 도우 가격, 토핑 가격
A, B = map(int, input().split())

# 도우 열량
C = int(input())

# 토핑 열량
D_list = []
for _ in range(N):
    D = int(input())
    D_list.append(D)

# 토핑 열량을 내림차순으로 정렬
D_list = sorted(D_list, reverse=True)

# 토핑이 없는 경우를 초기값으로 설정
max_value = C // A

# 열량이 높은 것부터 하나씩 추가하면서 1원당 열량 계산
for i in range(N):
    value = (C + sum(D_list[:i+1])) // (A + ((i+1) * B))

    # 최대값 비교
    if value > max_value:
        max_value = value
print(max_value)
```

### 로직

- 전체 로직
  - 토핑 열량을 내림차순으로 정렬
  - 열량이 높은 것부터 하나씩 추가해 가면서 1원당 열량 계산
  - 기존 최대값과 비교하면서 최대값 갱신

### 배운 점

1. 토핑이 하나도 올라가지 않은 피자가 최고의 피자가 될 수도 있기 때문에 최대값의 초기값을 토핑이 올라가지 않은 값으로 해야함



## 🔸 은지 angielxx

```python
# 토핑의 종류의 수
N = int(input())
# 도우의 가격, 토핑의 가격
A, B = map(int, input().split())
# 도우의 열량
C = int(input())
# N개의 토핑의 열량
toppings = [int(input()) for _ in range(N)]

# i번째까지의 합이 i+1 ~ N-1 까지의 합보다 클 때
# 제일 토핑의 수를 적게 선택하면서, 토핑의 열량을 가장 높게 가져갈 수 있음 (가격은 모두 동일하기 때문에)
# 0개 선택부터 토핑의 수를 열량이 큰 것부터 하나씩 선택해가며 1원당 열량을 구한다.
# 높아지다가 작아지는 값이 나왔을 때 정답을 출력한다.
toppings.sort(reverse=True)

# 토핑 열량의 합
sum_tops = 0
cnt = 0
# 칼로리 총합
cal = C
# 가격
price = A
# 1원당 열량
result = cal / price
# 스택에 1원당 열량 순서대로 저장, 값이 작아질 때 마지막 원소 출력
answer = result
for i in range(N):
    cal += toppings[i]
    price += B
    result = cal / price
    if result > answer:
        answer = result
    else:
        break

print(int(answer))
```

### 로직

- 아이디어
  - 1원당 열량이 가장 높아야한다 → 1원당 열량 = 총 열량 / 가격 → 열량은 가장 높고 가격은 가장 낮은 경우가 정답이므로, 토핑의 가격은 모두 동일하므로 토핑의 갯수는 최소화하며 열량을 최대로 가져가야한다.
  - 즉, 토핑의 열량을 큰것부터 선택한다. 내림차순으로 정렬하여 하나씩 더 선택하면서 1원당 열량이 커지는지 작아지는지 본다. ⇒ 값이 작아질 때 정답을 출력

### 배운 점

- 그리디 알고리즘을 100% 이해하지 못한 상태에서 푼 것 같은데, 이번 풀이를 통해 그리디에 대한 이해도를 높일 수 있었다.



## 🔸 찬빈 Rlack97

```python
N = int(input())
A, B = map(int,input().split())
C = int(input())
topping_cal = []

for i in range (N):
    D = int(input())
    topping_cal.append(D)
    # 입력값 받기

    
Bk = sorted(topping_cal,reverse=True)
# 역순으로 정렬 ( 1원당 칼로리 효율이 좋은 토핑 순서)

calories = C
price = A
max_value = C / A
# 값 변경을 위한 기본값 지정

for i in Bk:
    calories += i
    price += B
    # 가격과 칼로리를 하나씩 더해 줌

    if max_value < calories/price:
        max_value = calories/price
        # 더 좋은 값이 나온다면 갱신
    
    else :
        break
    # 그렇지 않다면 이미 효율은 계속 떨어질 수밖에 없으므로 브레이크


print(int(max_value))
```

### 로직

- 시간이 1초로 빡빡한 편이어서 역순정렬은 내장함수 사용.
- 가격이 전부 같기 때문에, 1원당 칼로리 효율이 줄어드는 시점 이후로는 계산할 필요가 없음

### 배운 점

갱신 비교를 위해서는 다른 변수를 추가 지정해줘야 주소복사로 인한 혼선이 안생긴다…



## 🔸 승준 ksj970714

```python
N = int(input())
A,B = map(int,input().split())
C = int(input())
D = []
for i in range(N):
    D.append(int(input()))

D.sort(reverse=True)

kcal = C
won = A
fat = [C/A]
for toping in D:
    kcal += toping
    won += B
    fat.append(kcal/won)


print(int(max(fat)))
```

### 로직

- 전체 로직
  - 정렬 후, 칼로리가 높은 토핑부터 순서대로 계산식에 추가하며 추가할때마다 fat이라는 리스트에 금액 대비 열량을 기록하였다.
  - 계산식은 (도우 열량+토핑 1의 열량+ 토핑 2의 열량 + ..) / (도우의 가격+지금까지 추가된 토핑 갯수X토핑 가격) 이다.
  - 이 계산식이 최대가 될 때가 최고의 피자이다.

### 배운 점

1. 역시, 난이도가 높지 않은 문제는 복잡한 알고리즘 고안보다 완전탐색이 좋다.
2. IM시험을 보며 느꼈는데 언뜻 보면 해답이 떠오르지 않는 어려운 문제에 대해, 그냥 손빨며 풀이만 생각하기보다 먼저 완전탐색, 브루트 포스 알고리즘으로 차근차근 접근하고 시간복잡도를 줄여가는 식으로 생각해보는 것이 큰 얼개를 잡기에 좋다는 점에서 괜찮은 습관인 것 같다.



## 🔸 유진 yjp8842

```python
# 최고의 피자 : 1원당 열량이 가장 높은 피자
# k종류의 토핑
# 피자의 가격 = A + B * k
# 토핑의 종류의 수 N
N = int(input())
# 도우의 가격 A, 토핑의 가격 B
A, B = map(int, input().split())
# 도우의 열량
C = int(input())
# 토핑의 열량
D = []
for _ in range(N):
    D.append(int(input()))

# 토핑의 열량을 내림차순으로 정렬한 리스트
r_list = sorted(D, reverse=True)

for i in r_list:
    cal = C + i
    price = A + B
  
    if (cal / price) > (C / A):
        (C / A) == (cal / price)
        
        A += B
        C += i
    
    # 값이 작아지는 순간 break -> C / A : 1원당 열량의 최댓값
    else:
        break

# 소수점 이하는 버리고 정수 값으로 출력
max_cal = int(C / A)

print(max_cal)
```

### 로직

- 토핑의 열량을 내림차순으로 정렬해주어 가장 열량이 큰 토핑부터 더해주며 1원당 가장 열량이 높은 순간을 찾아 출력해주었다.

### 배운 점

- 토핑의 열량은 달라도 가격은 같다는 점이 많은 도움이 되었다..



# 🔠 공통문제 2

## ⌛ 문제

언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.

그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.

이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.

### 출력

각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.



# 🔑 풀이



## 🔸 재승 joney0715

```python
import sys

# 계속 시간 초과나서 sys 사용
T = int(sys.stdin.readline())

for _ in range(T):
    N = int(sys.stdin.readline())
    N_list = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]
    
    # 서류 심사 결과로 정렬
    N_list.sort()
    
    # 서류 심사 1등은 자연스럽게 채용
    count = 1

    # 이후 면접 심사 결과로 비교
    k = N_list[0][1]

    # 나머지에 대해 반복
    for i in range(1,N):
        # 서류 1등보다 면접 등수가 낮으면 불합격
        # 면접 결과가 더 좋은 사람들만
        if N_list[i][1] < k:
            count += 1

            # 비교할 면접 결과 초기화
            k = N_list[i][1]

    print(count)
```

### 로직

- 전체 로직
  - 서류 심사 등수로 정렬을 한뒤 서류 1등은 채용조건을 만족 하므로 합격
  - 이후는 면접 등수로 결정
    - 서류 1등보다 면접 등수가 낮으면 서류 1등과 비교해서 모든 점수가 낮으므로 불합격
    - 면접 결과가 더 좋은 사람이면 카운트를 하나 올리고 그 사람으로 면접 점수 비교 기준 설정

### 배운 점

1. 문제를 조금 이해하기 어렵게 적어놓아서 문제 푸는데 생각보다 시간이 걸렸다
2. 한 점수라도 1등을 하면 합격이고 그 사람을 기준으로 다른 점수를 비교하는게 포인트



## 🔸 은지 angielxx

```python
import sys
input = sys.stdin.readline

T = int(input())

for _ in range(T):
    N = int(input())
    score = [list(map(int, input().split())) for _ in range(N)]
    score.sort()

    cnt = 1
    # 1등의 사람의 면접 순위
    top = score[0][1]
    for i in range(1, N):
        if score[i][1] < top:
            cnt += 1
            top = score[i][1]
        else:
            pass
    print(cnt)
```

### 로직

- 아이디어
  - 서류 성적을 기준으로 정렬했을 때, 나보다 서류 성적이 낮은 지원자들에 대해선 면접 성적을 비교할 필요가 없다. ⇒ 나보다 서류 성적이 높은 지원자들 중에 가장 높은 면접 성적을 갖고 있는 지원자하고만 면접성적을 비교하면, 나 자신의 채용 가능 or 불가능 여부가 결정된다.
- 로직
  - 서류 성적을 기준으로 지원자들을 정렬한다.
  - 서류 성적 1등인 지원자는 자동적으로 채용된다. (최소 서류성적에 대해 어떤 지원자에 대해서도 성적이 떨어지지 않기 때문이다.)
  - 서류 성적 2등인 지원자부터 채용여부를 살펴본다. 면접 성적 비교 대상은 서류 성적 1등인 지원자의 면접 성적이다.
  - 비교하고 있는 지원자의 면접 성적이 비교 대상의 면접성적보다 높으면 채용가능하다. (비교 대상은 서류 성적이 나보다 높음. 면접 성적도 나보다 높으면 채용이 안 된다. 비교 대상보다 서류 성적은 밀리는 상태에서 면접 성적은 높아야 채용이 되는데, 면접 성적이 내가 더 높다면 비교할 면접 성적을 업뎃한다.)
  - 반복해서 비교하며 채용가능한 지원자의 수를 센다



## 🔸 찬빈 Rlack97

```python
import sys
input = sys.stdin.readline

T = int(input())

for tc in range(1,T+1):
    N = int(input())
    aplicants = [0]*(N+1)
    for _ in range(N):
        first, second = map(int,input().split())
        aplicants[first] = second 
        # 한 쪽 성적을 기준으로 정렬

    answer = 1
    # 1등한 사람은 어쨌든 통과하므로
    top = aplicants[1]
    # 읽어들이는 순서에서 가장 등수가 낮은 합격자

    for i in range(2,N+1):
        if top > aplicants[i]:
            # 가장 등수가 낮은 합격자보다 등수가 높은가?
            # 배열 순서상 이미 한 쪽의 성적에서 지고 있으므로,
            # 이쪽에서도 등수가 더 낮으면 합격할 수 없음
            answer += 1

            # 조건을 통과했다면 합격 가능인수를 증가

            top = aplicants[i]
            # 가장 등수가 낮은 합격자 갱신

                
    print(answer)


# readline으로 시간단축해서 통과.... 진짜 돌겠네
```

### 로직

- 나보다 모든 등수가 높은 사람이 한명이라도 있으면 탈락이므로,
- 내림차순 정렬을 한 뒤 나머지 한 쪽의 성적만 비교
- 시간낭비를 줄이기 위해서 ‘자신 이외의 가장 낮은 등수의 성적자’ 와 비교할 필요가 있다

### 배운 점

- 점수랑 등수를 헷갈렸었다. 문제 꼼꼼히 읽자



## 🔸 승준 ksj970714

```python
T = int(input())
import sys

for test in range(T):
    N = int(input())
    vec = []
    mydict = {}
    for i in range(N):
        x,y = map(int,sys.stdin.readline().split())
        vec.append([x,y])

    vec.sort(key = lambda x:x[0])

    passed_man = len(vec)
    my_min = N+1
    for idx in range(len(vec)):
        if my_min > vec[idx][1]:
            my_min = vec[idx][1]
        else:
            passed_man -= 1


    print(passed_man)
```

### 로직

- 전체 로직
  - 두 가지 면접 성적을 x, y로 입력받아 vec이라는 리스트에 삽입하였다.
  - 이후, 람다함수를 사용해 x를 기준으로 오름차순 정렬하였다. (복잡도: O(n log n))
  - 합격자 수를 나타나는 passed_man에 총 참가자 수인 N을 넣어준다.
  - 정렬된 리스트를 0번부터 순회하며, my_min과 각 y를 비교해준다. x를 기준으로 정렬된 상태이므로, 왼쪽부터 순회한다고 가정할 때 왼쪽에서 가장 높은 순위(즉, 가장 작은 값=my_min) 보다 순위가 높지 않으면 어떤 지원자보다는 두 순위 모두 낮다는 의미이므로 떨어지게 된다. my_min보다 y가 작아 한 지원자가 떨어질 경우, passed_man 변수를 1 감소시킨다.
  - 만약 my_min보다 y가 작다면, x의 순위가 자기보다 높은 어떤 지원자보다도 y가 큰 것이기 때문에 y에 비교우위를 가지게 되어 합격가능성이 생긴다. 이 때는 my_min에 y를 집어넣어주고, passed_man을 감소시키지 않는다.
  - 순회가 끝나면 passed_man을 출력한다.
  - 리스트 순회하며  비교하는 방식은 리스트를 한번만 돌면 되므로, 시간 복잡도가 높지 않은 깔끔한 알고리즘이다.

### 배운 점

1. 시간 복잡도 개선

- 이중포문을 돌려서 풀었는데, 시간 초과가 났다. 이때 이런 알고리즘에 매달리지 말고, 아예 새로운 방법으로 방향을 틀어보는 것도 방법이라고 생각한다.
- 인간은 끊임없이 자기합리화를 하기 때문에, 하나의 알고리즘을 짜 놓으면 설사 그 알고리즘이 좋지 못하더라도 스스로 계속 정당화하고 보완하려고만 한다. 가끔은 과감하게 알고리즘의 아이디어 정도만 메모해놓고 싹 지운다음 새로 짜보는것도 방법이라고 생각한다.



## 🔸 유진 yjp8842

```python
# 서류심사 성적 혹은 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않으면 선발
# 서류심사나 면접시험 하나의 기준으로 먼저 정렬
# 그 다음 나머지 기준으로 결정하면 되지 않을까...?

T = int(input())
for i in range(1, T + 1):
    N = int(input())
    arr = []
    for _ in range(N):
        arr.append(list(map(int, input().split())))
        
    arr.sort()
    tmp = arr[0][1]
    people = 1
    
    for i in range(1, N):
        if tmp > arr[i][1]:
            tmp = arr[i][1]
            people += 1
    
    print(people)
    
    # readline 사용해서 시간초과 방지
```

### 로직

- 서류 심사의 기준으로 정렬한 후 면접시험의 순위를 가지고 서류 심사의 순위가 자신보다 높은 사람보다 면접시험의 순위가 높을 때만 people 변수를 하나씩 증가시켜 출력시켜주었다.

### 배운 점

- 두 개를 모두 비교하지 않고, 하나의 기준으로 정렬한 후 하나의 기준만 비교해주면 된다는 로직을 생각해내는게 쉽지 않았어서 보다 더 깔끔하고 쉬운 로직을 생각하는게 얼마나 중요한지 깨닫게 되었다.